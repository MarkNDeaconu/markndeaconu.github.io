---
title: "Qudit Datastructures"
publishedAt: "2025-03-16"
summary: "Making maps of arithmetic groups. Work is part of the paper 'Buildings and Synthesis for Clifford+R'"
images:
- "/images/projects/datastruc/qdata.gif"
team:
- name: "Mark Deaconu"
  role: "Software Engineer"
  avatar: "/images/avatar.jpg"
  linkedIn: "https://www.linkedin.com/in/mark-deaconu-621b44220/"
link: "https://github.com/MarkNDeaconu/QuditSynthesis"
---
# Escaping the Floating Point: A New Framework for Qudit Synthesis

While working with **Dr. Michele Mosca’s group** at the Institute for Quantum Computing (IQC), we fell down the rabbit hole of optimal *qudit* synthesis.

This wasn't just for the love of the math (though the algebra is fascinating); we knew that solving synthesis problems for higher-dimensional systems (qudits) could provide critical insights into how we approach standard multi-qubit synthesis.

As the intern, I was initially tasked with a "simple" job: exploring whether certain lemmas involving finite groups could be proven programmatically. However, I hit a wall immediately. I found that every existing quantum computing framework was restrictive in one of three ways:

1.  Too obsessed with **Qubits** (ignoring the d-dimensional world).
2.  Too focused on **Clifford** gates.
3.  **(The worst one)** Reliant on **floating-point arithmetic**.

I needed a fundamental, stripped-down approach that was reliable in the most general settings. Since it didn't exist, I built it.

### The Workflow
I designed the framework to handle the math exactly as it appears on the chalkboard:

1.  **Foundations:** Start with a (possibly) localized cyclotomic ring.
2.  **Construction:** Build operators directly out of element primitives.
3.  **Generation:** Generate the orbits of a set of generators.
4.  **Sampling:** Sample random elements from infinite groups.
5.  **The Test:** Verify if our synthesis methods can reliably reduce the chi-adic complexity of the sample, or use the tool to design your own method.

### Why It's Different
* **Zero Approximation:** This is the killer feature. All calculations are handled with **integer arithmetic**. There are no floating-point errors.
* **Universal Logic:** Despite the wide range of possible cyclotomic rings, the tool provides common functions that work uniformly on both elements and operators.
* **Auto-Normalization:** All elements and operators are automatically converted into their chi-adic reduced normal forms.

### The Reality Check
Of course, complexity theory still applies.
* We are currently restricted to **exact synthesis** only.
* Many of these synthesis problems are research-level and believed to be **NP-hard**. I can't really help you there—unless you have a million years to wait for the result.
